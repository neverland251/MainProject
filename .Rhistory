}
a(72)
a(76)
a(74)
a(73)
a(77)
a(78)
a(79)
pnorm(76.78318,78,10)
#1. X1,X2,X3,X4,X5가 중앙값 c인 코시분포에서 추출한 확률표본이다. 즉
# (1/pi)*(1/(1+(x-c)^2))가 공통 pdf인 iid이다.
# 확률표본의 값이 다음과 같다.
x <- c(-1.94,0.59,-5.98,-0.08,-0.77)
## 뉴턴법
## 코시분포의 pdf에 뉴턴법을 적용하기 위해 1계 미분을 실시하면
f_prime <- function(x,ceta){
2*sum((x-ceta)/(1+(x-ceta)^2))
}
f <- function(x,ceta){
length(x)*log(pi)+sum(log(1+(x-c)^2))
}
#초깃값으로 뉴턴법 함수를 1계 미분한 후 <0이 되도록 초깃값 ceta를 정해주는 방법도 있으나, 간단하게 x의 중앙값을 초깃값으로 사용해준다.
ceta <- median(x)
for(i in 0:10000){
ceta <- ceta - f(x,ceta)/f_prime(x,ceta)
print(ceta)
}
# 2. 뉴턴법을 활용하여 스테이너의 꼭지점을 도출하시오
## 스테이너의 꼭지점 함수 f = d1+d2+d3를 사용하시오
## 단, X1 =
## (단, dn = (x^2+y^2)^(1/2)인 L2norm)
steiner <- function(x,y){
for(i in rep(0:3000)){
f <- ((3-x)^2+y^2)^(1/2)+((x^2+y^2)^(1/2))+3
dfx <- (x/(x^2+y^2))-((3-x)/((3-x)^2+y^2))
dfy <- (y/((3-x)^2+y^2)) + (y/(x^2+y^2))
x <- x - f/dfx
y <- y - f/dfy
if(i%%100 == 0){
print(c(x,y))
}
else{
}
}
}
steiner(4,0)
steiner(1,1)
steiner(2,1)
steiner(1,2)
steiner(0,2)
steiner <- function(x,y){
for(i in rep(0:3000)){
f <- ((3-x)^2+y^2)+(x^2+y^2)+9
dfx <- 4*x - 6
dfy <- 4*y
x <- x - f/dfx
y <- y - f/dfy
if(i%%100 == 0){
print(c(x,y))
}
else{
}
}
}
steiner(1,1)
steiner(2,1)
steiner(0,01,0,01)
steiner(0.01,0.01)
steiner <- function(x,y){
for(i in rep(0:3000)){
dfx <- 4*x - 6
dfxx <- 4
dfy <- 4*y
dfyy <- 4
x <- x - dfx/dfxx
y <- y - dfy/dfyy
if(i%%100 == 0){
print(c(x,y))
}
else{
}
}
}
steiner(0.01,0.01)
steiner(1,1)
steiner(2,1)
steiner(100,1)
for(i in rep(0:3000)){
dfx <- 4*x - 6
dfxx <- 4
dfy <- 4*y
dfyy <- 4
x <- x - dfx/dfxx
y <- y - dfy/dfyy
print(c(x,y))
}
steiner <- function(x,y){
for(i in rep(0:3000)){
dfx <- 4*x - 6
dfxx <- 4
dfy <- 4*y
dfyy <- 4
x <- x - dfx/dfxx
y <- y - dfy/dfyy
print(c(x,y))
}
}
steiner(2,1)
for(i in rep(0:100)){
dfx <- 4*x - 6
dfxx <- 4
dfy <- 4*y
dfyy <- 4
x <- x - dfx/dfxx
y <- y - dfy/dfyy
print(c(x,y))
}
steiner <- function(x,y){
for(i in rep(0:100)){
dfx <- 4*x - 6
dfxx <- 4
dfy <- 4*y
dfyy <- 4
x <- x - dfx/dfxx
y <- y - dfy/dfyy
print(c(x,y))
}
}
steiner <- function(x,y){
for(i in rep(0:10)){
dfx <- 4*x - 6
dfxx <- 4
dfy <- 4*y
dfyy <- 4
x <- x - dfx/dfxx
y <- y - dfy/dfyy
print(c(x,y))
}
}
steiner(2,1)
data.frame(c(3.1,2.7,4.0),c(4.2,2.9,4.6),c(2.7,1.8,3.0),c(4.9,3.0,3.9))
q1 <- data.frame(c(3.1,2.7,4.0),c(4.2,2.9,4.6),c(2.7,1.8,3.0),c(4.9,3.0,3.9))
length(rownames(q1))
mean(q1)
mean(q1[,])
colMeans(q1)
mean(data.frame)
sum(q1)
length(q1)
## Q4는 sum(행)sum(열){열평균 - 전체평균}^2이고
## Q5는 sum(행)sum(열){관측값 - 열평균 - 행평균 + 전체평균)}^2 이다.
a <- length(rownames(q1))
b <- length(colnames(q1))
total <- a*b
## Q4에서, 이 함수는 행에 의존하지 않으므로 sum(행) -> length(행)으로 바뀌어서 곱해진다. 즉
Q4 <- a * sum((colMeans(q1)-(sum(q1)/total)))
Q4
(colMeans(q1)-(sum(q1)/total))
colMeans(q1)
q1 - colMeans(q1)
q1 - colMeans(q1) - rowMeans(q1)
q1 - colMeans(q1) - rowMeans(q1) + (sum(q1)/total)
sum(q1 - colMeans(q1) - rowMeans(q1) + (sum(q1)/total))
(Q4/(b-1))/(Q5/(a-1)(b-1))
Q5 <- sum(q1 - colMeans(q1) - rowMeans(q1) + (sum(q1)/total))
(Q4/(b-1))/(Q5/(a-1)(b-1))
(Q4/(b-1))/(Q5/((a-1)*(b-1)))
q1
q1-colMeans(q1)
colMeans(q1)
4.0 - 3.26667
rowMeans(q1)
4.6-3.9
4.0 - 3.266667
2.7-3.26667
(Q4/(b-1))/(Q5/((a-1)*(b-1)))
b-1
a-1
(a-1)*(b-1)
q1
sum(q1)
total
## Q4에서, 이 함수는 행에 의존하지 않으므로 sum(행) -> length(행)으로 바뀌어서 곱해진다. 즉
Q4 <- a * sum((colMeans(q1)-(sum(q1)/total)))^2
Q5 <- sum(q1 - colMeans(q1) - rowMeans(q1) + (sum(q1)/total))^2
## Q4에서, 이 함수는 행에 의존하지 않으므로 sum(행) -> length(행)으로 바뀌어서 곱해진다. 즉
Q4 <- a * sum((colMeans(q1)-(sum(q1)/total)))^2
Q5 <- sum(q1 - colMeans(q1) - rowMeans(q1) + (sum(q1)/total))^2
(Q4/(b-1))/(Q5/((a-1)*(b-1)))
colMeans(q1)
sum(q1)/total
mean(colMeans(q1))
## Q4에서, 이 함수는 행에 의존하지 않으므로 sum(행) -> length(행)으로 바뀌어서 곱해진다. 즉
Q4 <- a * sum(colMeans(q1)-(sum(q1)/total))^2
## Q4에서, 이 함수는 행에 의존하지 않으므로 sum(행) -> length(행)으로 바뀌어서 곱해진다. 즉
Q4 <- a * sum(colMeans(q1)-(sum(q1)/total)^2)
Q5 <- sum(q1 - colMeans(q1) - rowMeans(q1) + (sum(q1)/total)^2)
(Q4/(b-1))/(Q5/((a-1)*(b-1)))
## Q4에서, 이 함수는 행에 의존하지 않으므로 sum(행) -> length(행)으로 바뀌어서 곱해진다. 즉
Q4 <- a * sum((colMeans(q1)-(sum(q1)/total))^2)
Q5 <- sum((q1 - colMeans(q1) - rowMeans(q1) + (sum(q1)/total))^2)
(Q4/(b-1))/(Q5/((a-1)*(b-1)))
q1-colMeans(q1)
q1
colmeans(q1)
colMeans(q1)
3.1-3.266667
2.7-3.266667
(q1)-(colMeans(q1))
colMeans(q1)+rowMeans(q1)
(colMeans(q1)+rowMeans(q1))
q1
colMeans(q1)
q1[1,] - colMeans(q1)
q1[2,] - colMeans(q1)
q1[3,] - colMeans(q1)
q1[4,] - colMeans(q1)
q134,] - colMeans(q1)
q[3],] - colMeans(q1)
q[3,] - colMeans(q1)
q[2,] - colMeans(q1)
q1[2,] - colMeans(q1)
q1[3,] - colMeans(q1)
q1[4,] - colMeans(q1)
(q1-colMeans(q1))
data.frame(c(q1-colMeans(q1)))
data.frame(c(q1[1,]-colMeans(q1)))
data.frame(c(q1[1,]-colMeans(q1)),c(q1[2,]-colMeans(q1)),c(q1[3,]-colMeans(q1)))
data.frame((q1[1,]-colMeans(q1)),(q1[2,]-colMeans(q1)),(q1[3,]-colMeans(q1)))
data.frame(c(q1[1,]-colMeans(q1)),c(q1[2,]-colMeans(q1)),c(q1[3,]-colMeans(q1)))
?data.frame
data.frame(c((q1[1,]-colMeans(q1)),(q1[2,]-colMeans(q1)),(q1[3,]-colMeans(q1))))
c((q1[1,]-colMeans(q1)),(q1[2,]-colMeans(q1)),(q1[3,]-colMeans(q1)))
c(c(q1[1,]-colMeans(q1)),c(q1[2,]-colMeans(q1)),c(q1[3,]-colMeans(q1)))
list(c(q1[1,]-colMeans(q1)),c(q1[2,]-colMeans(q1)),c(q1[3,]-colMeans(q1)))
data.frame(c(q1[1,]-colMeans(q1)),c(q1[2,]-colMeans(q1)),c(q1[3,]-colMeans(q1)))
data.frame(q1[1,]-colMeans(q1),q1[2,]-colMeans(q1),q1[3,]-colMeans(q1))
data.frame(list(q1[1,]-colMeans(q1),q1[2,]-colMeans(q1),q1[3,]-colMeans(q1)))
data.frame(data.frame(q1[1,]-colMeans(q1),data.frame(q1[2,]-colMeans(q1)),data.frame(q1[3,]-colMeans(q1))))
rbind(data.frame(q1[1,]-colMeans(q1),data.frame(q1[2,]-colMeans(q1)),data.frame(q1[3,]-colMeans(q1))))
cbind(data.frame(q1[1,]-colMeans(q1),data.frame(q1[2,]-colMeans(q1)),data.frame(q1[3,]-colMeans(q1))))
cbind(data.frame(q1[1,]-colMeans(q1)),data.frame(q1[2,]-colMeans(q1)),data.frame(q1[3,]-colMeans(q1))))
cbind(data.frame(q1[1,]-colMeans(q1)),data.frame(q1[2,]-colMeans(q1)),data.frame(q1[3,]-colMeans(q1)))
rbind(data.frame(q1[1,]-colMeans(q1)),data.frame(q1[2,]-colMeans(q1)),data.frame(q1[3,]-colMeans(q1)))
rbind(data.frame(q1[1,]-colMeans(q1) - rowMeans(q1)),data.frame(q1[2,]-colMeans(q1) - rowMeans(q1)),data.frame(q1[3,]-colMeans(q1) - rowMeans(q1)))
Q5 <- sum((rbind(data.frame(q1[1,]-colMeans(q1) - rowMeans(q1)),data.frame(q1[2,]-colMeans(q1) - rowMeans(q1)),data.frame(q1[3,]-colMeans(q1) - rowMeans(q1))) + (sum(q1)/total))^2)
(colMeans(q1)-(sum(q1)/total)
)
colMeans(q1)
sum(q1)/total
(Q4/(b-1))/(Q5/((a-1)*(b-1)))
sum_q5 <- rbind(data.frame(q1[1,]-colMeans(q1) - rowMeans(q1)),data.frame(q1[2,]-colMeans(q1) - rowMeans(q1)),data.frame(q1[3,]-colMeans(q1) - rowMeans(q1)))
sum_q5
Q5 <- sum((q5 + (sum(q1)/total))^2)
(Q4/(b-1))/(Q5/((a-1)*(b-1)))
Q5
Q4
sum_q5
Q5 <- sum((sum_q5 + (sum(q1)/total))^2)
(Q4/(b-1))/(Q5/((a-1)*(b-1)))
sum_q5
q5
## Q4에서, 이 함수는 행에 의존하지 않으므로 sum(행) -> length(행)으로 바뀌어서 곱해진다. 즉
Q4 <- a * sum((colMeans(q1)-(sum(q1)/total))^2)
sum_q5 <- rbind(data.frame(q1[1,]-colMeans(q1) - rowMeans(q1)),data.frame(q1[2,]-colMeans(q1) - rowMeans(q1)),data.frame(q1[3,]-colMeans(q1) - rowMeans(q1)))
Q5 <- sum((sum_q5 + (sum(q1)/total))^2)
(Q4/(b-1))/(Q5/((a-1)*(b-1)))
Q4
Q5
q1
a
b
sum_q5
(sum_q5 + (sum(q1)/total))^2
sum((sum_q5 + (sum(q1)/total))^2)
(Q4/(b-1))
(Q5/(a-1)*(b-1))
colMeans(q1)
rowMeans(q1)
(colMeans(q1)-(sum(q1)/total))^2
colMeans(q1)-sum(q1/total)
colMeans(q1)
sum(q1/total)
(colMeans(q1)-(sum(q1)/total))^2
sum((colMeans(q1)-(sum(q1)/total))^2)
a * sum((colMeans(q1)-(sum(q1)/total))^2)
sum_q5
q1[1,] - colMeans(q1)
rowMeans(q1)
q1[2,] - colMeans(q1)
(Q4/(b-1))/(Q5/((a-1)*(b-1)))
y <- c(0.44,0.47,0.47,0.59,0.66,0.73,0.81,0.88,1.06,1.20,1.35,1.49,1.61,2.12,11.90,12.40,14.20,15.90,18.20,21.20,4.30,2.40,2.70,2.90)
y
x <- c(50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73)
x <- rep(50:73)
x
a <- mean(y)
a
(sum(y)*sum(x-mean(x)))/sum(x-mean(x))^2
mean(x)
sum(x-mean(x))
(sum(y*(x-mean(x)))/sum(x-mean(x))^2
afd
sum(y*(x-mean(x)))/sum(x-mean(x))^2
y*(x-mean(x))
sum(y*(x-mean(x)))
sum(y*(x-mean(x)))/sum((x-mean(x))^2
sum(y*(x-mean(x)))/sum((x-mean(x))^2)
sum(y*(x-mean(x)))/sum((x-mean(x))^2)
b <- sum(y*(x-mean(x)))/sum((x-mean(x))^2)
a + b*(x-mean(x))
y_hat <- a + b*(x-mean(x))
### 이에 대한 잔차는
y - y_hat
### 이에 대한 잔차는
err <- y - y_hat
sum(err^2)
sum(err^2)^(1/2)
### y의 분산은 이 잔차의 제곱의 합과 같다. 즉
y_var <- sum(err^2)
t.test(length(y)-2)
t_score
rm(t_score)
?t.test
a -
a
a
?ㄳ
?rt
qt(0.05,df=length(y)-2)
qt(0.025,df=length(y)-2)
a - ((y_var/length(y)-2)^(1/2))*qt(0.025,df=length(y)-2)
a + ((y_var/length(y)-2)^(1/2))*qt(0.025,df=length(y)-2)
a
Q4/(Q5
Q4/Q5
Q4/Q5
a - ((y_var/length(y)-2)^(1/2))*qt(0.975,df=length(y)-2)
a + ((y_var/length(y)-2)^(1/2))*qt(0.975,df=length(y)-2)
a - ((y_var/length(y)-2)^(1/2))*qt(0.975,df=length(y)-2)
t.test(a,0)
?t.test
## 2) a와 b의 신뢰구간을 t통계량을 이용하여 구하시오
### (a - a_true)/(y_var/(length(y)-2))^(1/2) 는 T(n-2)를 따른다. 신뢰구간은
lower <- a - ((y_var/length(y)-2)^(1/2))*qt(0.975,df=length(y)-2)
upper <- a + ((y_var/length(y)-2)^(1/2))*qt(0.975,df=length(y)-2)
c(lower,upper)
b - (length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2))
b - (length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2))^(1/2)
b - ((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2)
b - ((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2) * qt(0.975,df = length(y)-2)
lower <- b - ((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2) * qt(0.975,df = length(y)-2)
upper <- b + ((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2) * qt(0.975,df = length(y)-2)
c(lower,upper)
lm(y~x)
mean(y)
b
a <- lm(y~x)
a
summary(a)
((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2) * qt(0.975,df = length(y)-2)
((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2) * qt(0.95,df = length(y)-2)
((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2) * qt(0.025,df = length(y)-2)
b + ((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2) * qt(0.025,df = length(y)-2)
b + ((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2) * qt(0.05,df = length(y)-2)
b + ((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2) * qt(0.95,df = length(y)-2)
lower <- b - ((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2) * qt(0.975,df = length(y)-2)
lower
length(y)-2
y_var
### y의 분산은 이 잔차의 제곱의 합과 같다. 즉
y_var <- sum(err^2)/length(y)
## 2) a와 b의 신뢰구간을 t통계량을 이용하여 구하시오
### (a - a_true)/(y_var/(length(y)-2))^(1/2) 는 T(n-2)를 따른다. 신뢰구간은
lower <- a - ((y_var/length(y)-2)^(1/2))*qt(0.975,df=length(y)-2)
upper <- a + ((y_var/length(y)-2)^(1/2))*qt(0.975,df=length(y)-2)
c(lower,upper)
y_var
b - ((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2)
qt(b,df=length(y)-2)
ot(b,df=length(y)-2)
pt(b,df=length(y)-2)
dt(b,df=length(y)-2)
(length(y)-2)*sum((x-mean(x))^2))
length(y)-2)*sum((x-mean(x))^2)
(length(y)-2)*sum((x-mean(x))^2))
(length(y)-2)*sum((x-mean(x))^2)))
(length(y)-2)*sum((x-mean(x))^2)
(length(y)*y_var)/(length(y)-2)*sum((x-mean(x))^2)
((length(y)*y_var)/(length(y)-2)*sum((x-mean(x))^2))^(1/2)
((length(y)*y_var)/(length(y)-2)*sum((x-mean(x))^2))^(1/2)
lower <- b - ((length(y)*y_var)/(length(y)-2)*sum((x-mean(x))^2))^(1/2) * qt(0.975,df = length(y)-2)
upper <- b + ((length(y)*y_var)/(length(y)-2)*sum((x-mean(x))^2))^(1/2) * qt(0.975,df = length(y)-2)
c(lower,upper)
lower <- b - ((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2) * qt(0.975,df = length(y)-2)
upper <- b + ((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2) * qt(0.975,df = length(y)-2)
c(lower,upper)
b
((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2) * qt(0.975,df = length(y)-2)
summary(a)
?rt
dt(0.5041,df=22)
0.5041/(y_var/length(y)-2)
0.5041/(y_var/length(y)-2)^(1/2)
b/((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2)
(b - 0) / ((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2)
### 한편, h0 : mu = 0 가설 하에서 이에 해당하는 t통계량을 구하면
h_0 <- (b - 0) / ((length(y)*y_var)/((length(y)-2)*sum((x-mean(x))^2)))^(1/2)
dt(h_0,df=22)
## 이 때, 자유도 22 수준에서 H_0하 t통계량의 확률을 구하면
dt(h_0,df=22)
ss_ratio <- c(0.553,0.570,0.576,0.601,0.606,0.606,0.609,0.611,0.615,0.628,0.654,0.662,0.668,0.670,0.672,0.690,0.693,0.749,0.844,0.933)
ss_ratio
sgn_func <- function(x,c){
if(x - c > 0){
a <- a + 1
}
else{
}
}
sgn_func <- function(x,c){
for(i in x){
if(x - c > 0){
a <- a + 1
}
else{
}
}
}
sgn_func(ss_ratio,0.618)
a
a <- 0
sgn_func <- function(x,c){
for(i in x){
if(x - c > 0){
a <- a + 1
}
else{
}
}
}
sgn_func(ss_ratio,0.618)
ss_ratiop1]
ss_ratiopa1]
ss_ratiop[1]
ss_ratio[1]
warnings()
sgn_func <- function(x,c){
for(i in x){
if(i - c > 0){
a <- a + 1
}
else{
}
}
}
sgn_func(ss_ratio,0.618)
a
sgn_func <- function(x,c){
for(i in x){
if(i - c > 0){
a <- a + 1
}
else{
}
}
print(a)
}
sgn_func(ss_ratio,0.618)
b <- sgn_func(ss_ratio,0.618)
sgn_func <- function(x,c){
for(i in x){
if(i - c > 0){
a <- a + 1
}
else{
}
}
}
b <- sgn_func(ss_ratio,0.618)
b
sgn_func <- function(x,c){
for(i in x){
if(i - c > 0){
a <- a + 1
}
else{
}
}
a
}
b <- sgn_func(ss_ratio,0.618)
b
sgn_func <- function(x,c){
for(i in x){
if(i - c > 0){
a <- a + 1
}
else{
}
}
return(a)
}
b <- sgn_func(ss_ratio,0.618)
b
pbinom(b,0.5)
pbinom(b,length(ss_ratio),0.5)
2 * pbinom(b,length(ss_ratio),0.5)
pbinom(b,length(ss_ratio),0.5)
b
1 - pbinom(b,length(ss_ratio),0.5)
length(ss_ratio)
